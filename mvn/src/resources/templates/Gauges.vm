##################################################################
## 
## Licensed to the Apache Software Foundation (ASF) under one
## or more contributor license agreements.  See the NOTICE file
## distributed with this work for additional information
## regarding copyright ownership.  The ASF licenses this file
## to you under the Apache License, Version 2.0 (the
## "License"); you may not use this file except in compliance
## with the License.  You may obtain a copy of the License at
## 
##  http://www.apache.org/licenses/LICENSE-2.0
## 
## Unless required by applicable law or agreed to in writing,
## software distributed under the License is distributed on an
## "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
## KIND, either express or implied.  See the License for the
## specific language governing permissions and limitations
## under the License.
##
##################################################################
##
##
package net.amham.odfe.gauges;
import java.text.DateFormat;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.SortedMap;
import java.util.TreeMap;
import java.util.logging.Logger;

/* 
*
*  The current templates generate an output files XML which is used
*  to direct the output files based on the namespace
*       and a context back references the element name
*
*/
#set($elements = ${model.getElements().withoutMultiples()})

## Begin Code
##include('copyright.txt')
/*
 * This file is automatically generated.
 * Don't edit manually.
 */
//package org.odftoolkit.odfdom.dom.element.${NS};

##
## ---------------------------------------------------
##  Class
## ---------------------------------------------------
##
public class OdfGaugeStore {
	private final static   Logger LOGGER = Logger.getLogger(OdfGaugeStore.class.getName());
	
	private String name;
	private String rundate;
/*  // Declare the underlying data structure to hold the Gauge values

    // Create an ElementGauge Class and an AttributeGauge Class?

    // Or and Element Gauge contains a list of Attribute gauges

    // or we just have a map.isMandatory($Attribute) */
    SortedMap <String, SortedMap <String, OdfElementGauge>> namespaceGaugeMap = new TreeMap <String, SortedMap <String, OdfElementGauge>>();
	public OdfGaugeStore(String name) {
	    this.name = name;
	    DateFormat dateFormat = new SimpleDateFormat("yyyy/MM/dd HH:mm:ss");
	    Date date = new Date();
	    rundate = dateFormat.format(date);
	    
	    LOGGER.setUseParentHandlers(true);

	    loadNamespaces();
	}
	
	public String getName() {
		return name;
	}
	
	public String getRundate() {
		return rundate;
	}
	
	//This seems wrong... the store should hide the details
	public SortedMap <String, SortedMap <String, OdfElementGauge>> getNamespaceGaugeMap() {
		return namespaceGaugeMap;
	}

	public SortedMap<String, OdfElementGauge> getElementGaugeMap(String ns) {
		return namespaceGaugeMap.get(ns);
	}

	public Boolean hit(int ndx, String namespace, String element, String attribute) {
		Boolean found = false;
		
		LOGGER.fine("Hit ns:" + namespace + " " + element + " " + attribute);
		SortedMap<String, OdfElementGauge> nsElementGaugeMap = namespaceGaugeMap.get(namespace);
		if (nsElementGaugeMap != null ) {
		    OdfElementGauge gauge = nsElementGaugeMap.get(element);
		    if (gauge != null) {
		    	//attribute can be null and only the element gauge will be hit
			found = gauge.hit(ndx, attribute);
		    }
		    else {
			LOGGER.info("Unkown element " + element);
		    }
		}
		else {
			LOGGER.info("Unkown namespace " + namespace);
		}
		return found;

	}
	
	public void clearAll() {
		
		LOGGER.info("Clear All Gauges");
		
		for(String ns : namespaceGaugeMap.keySet()) {
			SortedMap<String, OdfElementGauge> nsElementGaugeMap = namespaceGaugeMap.get(ns);
			for(String element : nsElementGaugeMap.keySet()) {
			    OdfElementGauge gauge = nsElementGaugeMap.get(element);
			    gauge.clear();
			}
		}	
## closing brace provided below
#set($gaugeSpace = "")
#foreach( $element in $elements )
#if ($element != "*")
#if ($gaugeSpace != "${model.extractNamespace($element)}")
#set($gaugeSpace = "${model.extractNamespace($element)}")
	}
	
	//where has the code gone??
	public void load${model.camelCase($gaugeSpace)}() {
		SortedMap <String, OdfElementGauge> ${gaugeSpace}ElementGaugeMap = new TreeMap <String, OdfElementGauge>();
	    namespaceGaugeMap.put("$gaugeSpace", ${gaugeSpace}ElementGaugeMap);
#end
#set($gaugeName = "${model.javaCase($element)}")

        OdfElementGauge ${gaugeName}Gauge = new OdfElementGauge("${element}");
    
#foreach( $attribute in ${element.getAttributes().withoutMultiples()} )
#if ($attribute != "*")
#if( ${element.isMandatory($attribute)} )
        ${gaugeName}Gauge.addAttribute(new OdfAttributeGauge("${attribute}", true));
#else
        ${gaugeName}Gauge.addAttribute(new OdfAttributeGauge("${attribute}", false));
#end
#end
#end

        ${gaugeSpace}ElementGaugeMap.put("$element", ${gaugeName}Gauge);
#end
#end
    }
##
## Again through the elements to call the loadNamespace functions
##
#set($gaugeSpace = "")

	public void loadNamespaces() {

#foreach( $element in $elements )
#if ($element != "*")
#if ($gaugeSpace != "${model.extractNamespace($element)}")
#set($gaugeSpace = "${model.extractNamespace($element)}")
	    load${model.camelCase($gaugeSpace)}();
#end
#end
#end	

	}  

}
